---
title: "우아한테크코스 프리코스 1주차"
date: 2025-10-19 15:00:00 +09:00
categories: [WTC, Precourse]
tags: [boot camp, back end]
image:
  path: /assets/img/WTC/WTC_Thumbnail.png
---

> 우아한 테크코스의 프리코스를 진행하며 요구사항에 대한 해석, 어려운점 등. 을 적어가는 블로그 포스트 입니다. 주어진 요구사항들을 하나씩 만족시켜 나가며, 제가 겪는 문제 해결 과정과 고민의 흔적을 담아내는 내용입니다. 단순한 정답 코드를 나열하는 것이 아닌, 왜 이런 코드를 작성했고, 어떤 부분에서 어려움을 겪었는지에 대한 두서없는 글이며, 이 기록이 글을 보시는 분들께도 작은 도움이 되었으면 좋겠습니다.


## **미션 요약 및 생각**
> 1주차 미션을 보고 처음으로 의문을 가졌던 생각이며 **목차**라고 볼 수 있습니다.  

* [개발환경 구성 및 제출](#개발환경-구성-및-제출)
* [커스텀 구분자 구현](#커스텀-구분자-구현)
* [클린코드 및 코드 컨벤션](#클린코드-및-코드-컨벤션)

## **개발환경 구성 및 제출**
우선 첫번째로 든 생각으로는 **비전공자** 분들은 처음부터 꽤나 어려울 만한 요구사항이라는 생각을 했습니다.  
물론 [제출 가이드](https://github.com/woowacourse/woowacourse-docs/tree/main/precourse#%EC%A0%9C%EC%B6%9C-%EA%B0%80%EC%9D%B4%EB%93%9C){:target="_blank"}를 제공해주기 때문에 따라한다면 미션을 제출하는 것에 있어서 큰 문제는 없을 것으로 예상되지만, 이해하며 따라하는것과 무작정 따라하는 것은 큰 차이가 있다고 생각하였고 `fork`, `branch`, `commit` 등 **Git**에 대한 용어와 사용법에서 어려움이 있었을거라 생각했습니다.  

전공자인 저는 오히려 간단한 곳에서 어려움이 있었으며, 그 어려움은 **통합 개발 환경(IDE)으로 가져오기** 부분이 꽤나 어려웠습니다. 제출가이드에서 제공하는 자료가 인텔리제이의 구버전이라서 `Import Project` 이후 `Gradle` 모델을 선택하는게 `2024.2.1` 버전과는 UI가 달라 꽤나 애먹었습니다. 

---
**문제상황: 설명 문서와 달리 import project 버튼이 존재하지 않고, 어렴풋이 따라해도 구조가 다르다.**

사실 이 부분에서 제가 할 수 있는건 구글링 밖에 없기 때문에 계속해서 찾아봤고, 저와 비슷한 의문점을 가진 블로그 글이 있었습니다.  

[참고 블로그_1](https://velog.io/@s0nnyday/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4intellij%EC%97%90-import-%ED%95%98%EA%B8%B0){:target="_blank"}, 
[참고 블로그_2](https://gyucheolk.tistory.com/45){:target="_blank"}  

> 해결방법: File -> Open -> import할 프로젝트의 build.gradle 선택 후 Open as Project 선택
{: .prompt-tip }
---

## **커스텀 구분자 구현**
> **기능 목록 단위**
> 1. 문구 출력 -> Console.readLine()으로 사용자 입력받기. 결과를 형식에 맞게 출력하기
> 2. 입력된 문자열이 비어있거나, null일 경우 -> 0을 반환하는 기능.
> 3. 쉼표(,) 또는 콜론(:)을 기준으로 문자열을 분리하는 기능, 분리된 각 숫자의 합을 계산하여 반환하는 기능.
> 4. **--> //와 \n 사이의 문자를 커스텀 구분자로 인식하여 문자열을 분리하고 합을 계산하는 기능. <--**
> 5. 분리된 숫자를 확인하여 음수가 포함되어 있을 경우 IllegalArgumentException을 발생시키는 기능.
> 6. 잘못된 값의 확장 (예: "1,a,2", "//;\n1;abc;3")
> 7. 클린코드 리팩토링 -> 단일책임 원칙 유사 구현

기능 목록을 저만의 방법으로 나누어 진행하였고 4번째인 **커스텀 구분자 기능 구현**에서 어려움이 있었습니다.  
커스텀 구분자에 대한 기능요구사항을 보고는 **정규표현식**을 사용해야겠다는 생각을 시작으로 `Matcher` , `Pattern` 내부 라이브러리를 사용하여 구현하는 도중 생겨난 문제입니다.

```java
public static int calculateSum(String text) {
    if (text == null || text.isEmpty()) {
        return 0;
    }

    // 기본 구분자
    String delimiter = ",|:";
    String numbersText = text;

    // ==========================[문제 발생]===============================
    // "//"와 "\n" 사이의 커스텀 구분자 찾기
    Pattern pattern = Pattern.compile("//(.)\n(.*)");
    Matcher matcher = pattern.matcher(text);
    if (matcher.find()) {
        delimiter = Pattern.quote(matcher.group(1)); // 찾은 구분자
        numbersText = matcher.group(2);      // 숫자 부분
    }
    // ===================================================================

    String[] numbers = numbersText.split(delimiter);

    int sum = 0;
    for (String numberStr : numbers) {
        sum += Integer.parseInt(numberStr);
    }

    return sum;
}
```
**내부 라이브러리 `pattern` 을 사용하면서 생겨난 의문점이었는데요. 의도한 로직은 이렇습니다.**

1. **패턴정의 `Pattern.compile("//(.)\n(.*)")`**
  - `//`: 문자열이 "//"로 시작해야 합니다.
  - `(.)`: `//` 바로 뒤에 오는 임의의 문자 한 개를 찾아서 첫 번째 그룹으로 캡처(저장)합니다. 이 문자가 바로 커스텀 구분자가 됩니다.
  - `\n`: `\n` (줄바꿈 문자)를 찾습니다.
  - `(.*)`: 줄바꿈 문자 뒤에 오는 모든 문자열을 찾아서 두 번째 그룹으로 캡처합니다. 이 부분이 합계를 구할 숫자들이 있는 문자열이 됩니다.
2. **패턴 매칭 (Matcher Find) `Matcher matcher = pattern.matcher(text);`**
  - 정의한 패턴을 입력받은 `text` 문자열에 적용하여 `Matcher` 객체를 생성합니다.
  - `if (matcher.find())`
  - `find()` 메서드를 호출하여 `text` 문자열 안에서 위에서 정의한 패턴과 일치하는 부분이 있는지 검사합니다.
  - 일치하는 경우 (커스텀 구분자가 있는 경우): `true`를 반환하고 `if` 블록 안의 코드가 실행됩니다.
  - 일치하지 않는 경우 (커스텀 구분자가 없는 경우): `false`를 반환하고 `if` 블록을 건너뜁니다.

### **문제 해결**
계속해서 오류가 뜨다보니, 코드를 하나하나 뜯어가며 확인해본 결과 
```java
Pattern pattern = Pattern.compile("//(.)\n(.*)"); // <<-- 주요 오류지점
```
이 코드 줄에서 문제가 발생하는 것을 알 수 있었고, `\n` 부분에서 큰 문제가 있었습니다. 아마 **정규표현식에 대한 미숙함**도 있었겠지만, 새로운 사실도 알게 되었습니다.

**`\n`의 문자열을 찾기위해서는 `\` 백슬레쉬를 하나 더 작성하여 `\\n` 의 형태로 `\n`을 찾는다는 것이었습니다.**  

그럼에도 오류는 해결되지 않아 조금 더 찾아본 결과 IDE 컴파일 환경에서도 **`\\ -> \`** 의 과정을 거치고 **`Pattern.compile()`** 메서드의 컴파일 에서도 **`\\ -> \`**  과정을 거치기 때문에  

**결국 `Pattern pattern = Pattern.compile("//(.)\\\\n(.*)");` 즉, `\\\\` 백슬레쉬를 4번 작성해야 오류가 해결된다는 결과를 얻었습니다.**

---

## **클린코드 및 코드 컨벤션**

1주차 요구사항에서는 **코드컨벤션**에 대한 요구사항만 있었고, **클린코드**에 대한 요구사항은 없었지만, [woowacourse-docs](https://github.com/woowacourse/woowacourse-docs){:target="_blank"} 를 자세히 읽어보고 어렴풋이 따라는 해보는것이 좋겠다고 생각하여 **두 조건 모두 적용하는 시간**을 가져보았습니다.  

> [코드-컨벤션](https://github.com/woowacourse/woowacourse-docs/tree/main/styleguide/java){:target="_blank"}  
> [클린-코드](https://github.com/woowacourse/woowacourse-docs/blob/main/cleancode/pr_checklist.md){:target="_blank"}  

**코드 컨벤션**은 우테코 디스코드에서 **자동적용 방법**에 대한 내용을 공유해주셔서 저 또한 적용하는 시간을 가졌습니다. 그러나 클린코드는 직접 제가 검수하는게 이로울것 같아 한번 스스로 리팩토링을 해보았습니다.

### **[기존코드](https://github.com/woowacourse-precourse/java-calculator-8/blob/89191f275fd968b8a80dc0871e6cf241ad31feb8/src/main/java/calculator/Application.java){:target="_blank"}**
```java
// for문 안에 if, try-catch가 중첩되어 있던 버전
public static int calculateSum(String text) {
    // ... 복잡한 로직 ...
    for (String numberStr : numbers) {
        if (numberStr.isEmpty()) {
            // ...
        }
        try {
            if (number < 0) {
                // ...
            }
        } catch (NumberFormatException e) {
            // ...
        }
    }
    return sum;
}
```
기존코드는 모든 기능을 `calculateSum()` 함수에 다 때려박았는데, 클린코드 법칙에서 **'한 메서드에 한 단계 들여쓰기'** 규칙을 위반하고 있다고 생각을 했었고, 기본적 으로 복잡하게 보인다는 생각이 들어 리팩토링을 진행 하였다.

### **[수정코드](https://github.com/woowacourse-precourse/java-calculator-8/blob/bdecd519955ef2bcf8a2788280cad1504bc8ffa9/src/main/java/calculator/Application.java){:target="_blank"}**

```java
// calculate, splitText, sumTokens, parsePositiveNumber로 분리된 버전
public static int calculate(String text) {
    // ...
}

private static String[] splitText(String text) {
    // ...
}

private static int sumTokens(String[] numberTokens) {
    // ...
}

private static int parsePositiveNumber(String token) {
    // ...
}
```
- `calculate()`: 전체 계산 흐름을 관리
- `splitText()`: 문자열을 분석하고 분리하는 책임
- `sumTokens()`: 분리된 숫자 문자열들의 합계를 구하는 책임
- `parsePositiveNumber()`: 하나의 문자열을 검증하고 숫자로 변환하는 책임

위와 같이 역할을 명확히 나눈 작은 메서드들로 코드를 재구성함으로써, 각 메서드의 의도가 명확해지고 테스트와 유지보수가 용이한 구조를 만들 수 있었습니다.

### **리팩토링 후 아쉬운 점**
**프로그래밍 요구사항**에서 **`프로그램 실행의 시작점은 Application의 main()이다.`** 의 부분을 처음에는 **`Application`** 파일 안에서만 코드를 구현하하는 의미인줄 알고, **클래스 분리가 아닌 메서드 분리**를 진행하였지만  

지금와서 생각을 해보면 **클래스**를 **분리**하여 **단일 책임 원칙** 을 확실히 구현해보는 것이 좋았을 것 같다는 생각이 있었다.

## **요약**

1주차 미션은 단순한 '코딩 과제'가 아니었습니다. 기능 구현 자체의 난이도보다는, 좋은 개발자가 되기 위해 갖춰야 할 기본적인 정보를 온몸으로 체득하는 과정에 가까웠습니다. Git을 통해 버전을 관리하고, 정해진 컨벤션에 맞춰 동료와 소통하는 법을 배우며 '함께 일하는 방식'에 대해 처음으로 깊이 고민해볼 수 있었습니다.

특히, 처음에는 까다롭게만 느껴졌던 클린 코드 원칙들을 적용하며 코드를 리팩토링하는 과정은 제게 가장 큰 성장을 안겨주었습니다. 단순히 동작하는 코드를 넘어, 다른 코드리뷰어가 읽기 쉽고 유지보수가 용이한 코드를 작성하는 것이 왜 중요한지 우테코에서 요구사항으로 조건을 걸 정도로 회사 내에서도 중요한 습관이겠구나 라는 깨닫는 시간이었습니다.

물론, 요구사항에 대한 오해에서 비롯된 아쉬움도 남았지만, 그 아쉬움마저 다음 미션을 더 잘 해내고 싶다는 강력한 동기부여가 되었습니다. 이번 1주차 경험을 발판 삼아, 앞으로 남은 프리코스 기간 동안 기술적으로나 협업 문화적으로나 한 층 더 성장하는 모습을 기록해 나가겠습니다.

