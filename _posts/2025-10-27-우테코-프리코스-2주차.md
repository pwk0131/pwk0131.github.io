---
title: "우아한테크코스 프리코스 2주차"
date: 2025-10-27 15:00:00 +09:00
categories: [WTC, Precourse]
tags: [boot camp, back end]
image:
  path: /assets/img/WTC/WTC_Thumbnail_2week.png
---

> 우아한 테크코스의 프리코스를 진행하며 요구사항에 대한 해석, 어려운점 등. 을 적어가는 블로그 포스트 입니다. 주어진 요구사항들을 하나씩 만족시켜 나가며, 제가 겪는 문제 해결 과정과 고민의 흔적을 담아내는 내용입니다. 단순한 정답 코드를 나열하는 것이 아닌, 왜 이런 코드를 작성했고, 어떤 부분에서 어려움을 겪었는지에 대한 두서없는 글이며, 이 기록이 글을 보시는 분들께도 작은 도움이 되었으면 좋겠습니다.

## **2주차 미션을 진행하며**
2주차 미션을 진행하며 새로운 것을 도전해보는, 혹은 도전을 의도적으로 해보는 것에 중점을 두었습니다.
그 도전은 1주차에서 못해본 **클래스 분리** 였으며 **MVC** 패턴을 구상하고 시작하며 자동자 경주 미션을 진행하였습니다.

1주차에서는 **메소드로 책임을 분리**하였다면, 2주차는 **클래스 단위**로 분리하여 단일책임원칙을 구현해보았습니다.
그리고 의도적 도전은 처음 코드는 **클린코드**를 의식하지 않고 코드를 작성한 후, 리팩토링을 진행해 보는 것이었습니다.


## **전체적인 구조** -> [코드 보러가기](https://github.com/woowacourse-precourse/java-racingcar-8/pull/643){:target="_blank"}
![구조](../assets/img/WTC/2week/2주차%20아키텍쳐.png)

### **Controller (제어)**
- **파일: GameController.java****
- **역할: 애플리케이션의 전체 흐름을 제어하는 역할**
- **책임**: 
    - `InputView`를 통해 사용자 입력을 받습니다.
    - 입력값을 `Model(Cars)`에 전달하여 핵심 로직을 실행하도록 명령합니다.
    - `Model`로부터 처리된 데이터(`CarDto`)를 받습니다.
    - `OutputView`에 데이터를 전달하여 사용자에게 결과를 보여주도록 명령합니다.

### **Model (Domain - 핵심 로직)**
- **파일: Cars.java, Car.java, Name.java, Position.java**

- **역할: 애플리케이션의 핵심 비즈니스 규칙을 담고 있습니다. "자동차 경주"라는 문제의 본질을 해결하는 코드입니다.**
- **책임:**
    - `Name`, `Position`: '원시값 포장(Primitive Obsession)'을 방지하는 **Value Object(값 객체)**입니다. `Name`은 이름의 유효성 검사(5자 이하, 공백 금지)를, `Position`은 위치값의 불변성을 보장합니다.
    - `Car`: 단일 자동차의 상태(`Name`, `Position`)와 행위(`move`)를 책임집니다.
    - `Cars`: 자동차들(`List<Car>`)을 관리하는 **'일급 컬렉션(First-Class Collection)'**입니다. 이름 중복 검사, 모든 차 이동(`moveAll`), 우승자 찾기(`findWinners`) 등 자동차 '그룹'에 대한 로직을 처리합니다.
- **특징: 이 계층은 `View`나 `Controller`의 존재를 전혀 알지 못합니다. 오직 자신의 규칙과 논리만 수행합니다.**

### **View (입출력)**
- **파일: `InputView.java`, `OutputView.java`**
- **역할: 사용자에게 보여지는 부분(출력)과 사용자로부터 입력을 받는 부분(입력)을 전담합니다.**
- **책임:**
    - `InputView`: `Console`에서 사용자 입력을 읽는 역할(`readCarNames`, `readTryCount`)과 입력값 자체의 유효성 검사(숫자인지, 비어있는지)를 담당합니다.
    - `OutputView`: `System.out.println`을 사용하여 사용자에게 메시지(라운드 결과, 최종 우승자)를 출력합니다.
- **특징: 이 계층은 `Model`의 비즈니스 로직(예: '4 이상일 때 전진한다')을 전혀 알지 못합니다. 오직 입출력만 담당합니다.**

### **DTO (Data Transfer Object)**
- **파일: `CarDto.java`**
- **역할: 계층 간(특히 Model에서 View로) 데이터를 전달하기 위한 운반용 객체입니다.**
- **책임:** `Car` 객체는 `move()`와 같은 행위를 가지고 있지만, `View`는 단순히 '이름'과 '위치값'만 필요합니다. `CarDto`는 `Model`의 핵심 객체(`Car`)를 `View`에 직접 노출시키지 않고, 오직 `View`가 필요로 하는 데이터만을 담아서 전달합니다.
- 효과: `Model`과 `View` 사이의 **의존성을 분리(Decoupling)**하여, `View`가 변경되어도 `Model`이 영향을 받지 않고, `Model`이 변경되어도 `View`가 영향을 덜 받게 합니다.

### **Application (진입점)**
- ***파일: `Application.java`***
- **역할: 프로그램의 시작점입니다.**
- **책임:** `GameController`를 생성하고 `run()` 메소드를 호출하여 전체 애플리케이션을 실행시킵니다.


## 😂 **Getter 사용하지 말라고만 하면..**
이번 주차에서 클린코드 규칙을 빡세게 적용해보려고 하면서 의문점이 든 규칙은 `getter/setter 없이 구현했는가?` 였습니다.  

실제로 자바를 배우거나, 프로젝트를 진행하며 `Getter` / `Setter` 많이 사용했었던 기억이 있었습니다.. 그러나 우테코에서는 지양하라는 규칙을 보고 의문점이 생겨 이번 2주차에 적용시켜 보며 이유를 알아가려 합니다.

결론은 **미래에 변경될 코드를 쉽게 만들기 위해서** 즉 **유지보수성**과 **안정성**을 극단적으로 높이기 위한 객**체지향 설계 훈련법**입니다. 

--- 

### 1. **getter/setter를 사용하지 않는 이유 (DTO `CarDto.java` 제외)**
객체지향의 핵심 원칙인 "Tell, Don't Ask (묻지 말고, 시켜라)" 를 지키기 위해서입니다.

**나쁜 예시 (Ask: '물어보기') getter는 객체의 내부 데이터를 밖으로 꺼내는 행위입니다.**
```java
// Controller나 Service가 '묻는' 방식
Position carPosition = car.getPosition(); // 1. Car의 위치를 '묻는다'.
Position maxPosition = ...;

if (carPosition.isGreaterThan(maxPosition)) { // 2. 외부에서 로직을 수행한다.
    // ...
}
```
- **문제점**: `Car` [Car.java] 객체는 자신의 `position` [Position.java] 데이터를 그냥 밖으로 노출했습니다. ``GameController`` [GameController.java] 같은 외부 클래스가 그 데이터를 가져가서 if문이라는 "핵심 로직"을 직접 수행합니다.

- **결과**: ``Car``는 그냥 "데이터 깡통"이 됩니다. 만약 우승자 판별 로직이 바뀐다면, `Car`가 아니라 `GameController`를 수정해야 합니다. 데이터와 로직이 분리된 것입니다.

**좋은 예시 (Tell: '시키기') getter 대신, 객체에게 "네가 가진 데이터로 이 일을 처리해 줘"라고 '시킵니다'.**
```java
// Controller가 '시키는' 방식
Position maxPosition = ...;
car.addIfWinner(maxPosition, winnerList); // 1. Car에게 "네가 우승자인지 확인하고 리스트에 추가해"라고 '시킨다'.

// Car.java 내부
public void addIfWinner(Position maxPosition, List<String> winnerList) {
    if (this.position.isGreaterThan(maxPosition)) { // 2. 로직이 Car 내부에 있다.
        winnerList.add(this.name.toString());
    }
}
```
**이점**: 우승자를 판별하는 로직(`if (this.position.isGreaterThan...)`)이 `Car` 객체 내부에 캡슐화되었습니다. `GameController` [GameController.java]는 `Car`가 어떻게 우승자를 판별하는지 알 필요가 없습니다.

**결과**: `Car`는 "스스로 일을 처리하는" 스마트한 객체가 됩니다. 나중에 로직이 바뀌면 `GameController`[GameController.java]는 건드리지 않고 `Car` 클래스만 수정하면 됩니다.

**DTO [CarDto.java]는 왜 허용되나요?**    
`View` [OutputView.java] 계층은 예외입니다. `View`의 유일한 책임은 데이터를 보여주는 것이기 때문에, 도메인(로직) 계층에서 `View`(표시) 계층으로 **"로직 없이 데이터만" 전달할 통로가 필요합니다. DTO가 바로 그 통로입니다.**

### **요약**

요약하자면 이 엄격한 규칙들은 **변경이 발생할 때, 코드를 수정해야 하는 범위를 최소한으로 줄이기 위해** 존재한다는걸 알게 되었습니다.

- `getter` 금지 -> 로직을 데이터가 있는 객체 내부로 **캡슐화**합니다.

이 규칙들을 지키면 당장은 코드가 길어지고 클래스가 많아지지만, 1년 뒤에 기능을 수정할 때는 `Car` [Car.java] 객체 하나만 고치면 된다는 것을 보장받게 될겁니다.

## 마무리
2주차를 진행하며 1주차때 못해본 클래스 분리를 진행했고, 클래스 분리를 이어나가 클린코드의 의도까지 파악해 보았습니다.  
앞으로의 3주차는 LLM의 도움없이 스스로 구현해보는 도전을 해보는 시간을 가져볼려고 합니다.
